### 并发一致性问题

- 丢失修改
- 读脏数据
- 不可重复读
- 幻影读

### 封锁

- 封锁的粒度
  - 行级锁
  - 表级锁
- 封锁的类型
  - 读写锁
    - 互斥锁
    - 共享锁
  - 意向锁
- 封锁的协议
  - 三级封锁协议
    - 一级封锁协议
    - 二级封锁协议
    - 三级封锁协议
  - 两段锁协议
- MySQL隐式与显示锁定

### 隔离级别

- 未提交读
- 提交读
- 可重复读
- 可串行化







## MySQL

1. 对于大部分应用来说，通常自增类型的主键就能满足需求。我们在`students`表中定义的主键也是`BIGINT NOT NULL AUTO_INCREMENT`类型。如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。
2. 主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型（全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似`8f55d96b-8acc-4636-8cb8-76bf8abc2f57`。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键）。主键也不应该允许`NULL`。可以使用多个列作为联合主键，但联合主键并不常用。
3. 有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表`user_info`和用户详细信息表`user_profiles`，大部分时候，只需要查询`user_info`表，并不需要查询`user_profiles`表，这样就提高了查询速度。
4. 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如`gender`列，大约一半的记录值是`M`，另一半是`F`，因此，对该列创建索引就没有意义。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。
5. 在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。

```sql
ALTER TABLE students
ADD UNIQUE INDEX uni_name (name);//唯一索引

ALTER TABLE students
ADD CONSTRAINT uni_name UNIQUE (name);//唯一约束
```

6. 在查询中要组合三个或者更多的条件，就需要用小括号`()`表示如何进行条件运算。如果不加括号，条件运算按照`NOT`、`AND`、`OR`的优先级进行，即`NOT`优先级最高，其次是`AND`，最后是`OR`。加上括号可以改变优先级。