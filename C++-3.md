







## 一、类的问题

---

#### 封闭类

封闭类：类的成员属性为其他类的对象，这种类称为封闭类，这个成员属性称为成员对象；

封闭类要注意构造问题，因为涉及成员对象的构造；

封闭类在执行拷贝构造的时候，成员对象也会执行拷贝构造；

---

#### 构造与析构的顺序

- 对于封闭类，先构造成员对象，再构造封闭类，先析构封闭类对象，再析构成员对象；成员对象的构造顺序与声明顺序一致；
- 对于基类-派生类，在声明派生类对象的时候，先构造基类，再构造派生类，析构时先析构派生类，再析构基类；

---

#### 继承

- 三种继承方式，public、protected、private，无论哪种方式，派生类都会继承得到基类的所有成员变量与成员函数，但是派生类无法访问基类的`private`成员；

  |  继承方式   |             继承得到的成员的权限             |
  | :---------: | :------------------------------------------: |
  |  `public`   |  `public->public` \ `protected->protected`   |
  | `protected` | `public->protected` \ `protected->protected` |
  |  `private`  |   `public->private` \ `protected->private`   |

- 派生类对象的大小 = 基类成员变量大小 + 派生类成员变量大小；

- 两个类可能拥有的关系：继承、复合；

- 父类指针指向子类对象时，指针类型仍然是父类对象，因此可以通过指针访问其public成员，访问结果是子类重写父类虚函数的结果，但是指针不能访问子类中非继承的成员（必须将指针强转之后才能访问）；

---

#### 多态









---

## 二、关键字问题

---

#### const关键字

- 常量对象，声明对象时在前面加const；
- 常量成员函数：在类的成员函数后面加const关键字；
  - 常量成员函数不能修改成员变量的值；（静态成员变量）
  - 常量成员函数不能调用一般成员函数；（静态成员函数）
  - const可以作为重载的条件；
- 常引用：在引用前加const关键字；
  - 不能通过常引用修改引用对象的值；
  - 利用常引用作为函数参数，可以防止引发拷贝构造`(拷贝构造一个临时对象，类似于值传递，徒增开销)`，同时又可以避免形参误修改实参；

---



## 三、重载、重写、重定义

---

#### 重载

##### 运算符重载

- 解决自定义对象无法使用预定义运算符进行运算的问题；

  ```c++
  返回值类型 operator 运算符(形参表){ }
  ```

- 赋值运算符只能重载为成员函数；

  - 如果存在指针成员变量，那么还要考虑的浅拷贝、深拷贝问题，让等号的左值对象与右值对象中的指针成员变量不是指向同一块内存；默认下是浅拷贝，所以会出现问题，要利用赋值运算符重载实现深拷贝；
  - 赋值运算符重载的返回值一般是引用的形式；

- ++运算符重载

  - 实现前置++重载；返回值为T&
  - 后置++利用前置++实现；返回值为T
  - 后置运算符重载在执行步骤上要多一个临时变量的生成与赋值；因此前置运算符的重载函数比后置运算符的重载函数性能更高，开销更小；

- 输入输出流运算符的重载：重载ostream类的`<<`运算符和istream类的`>>`运算符，并且只能重载成全局函数；



##### 函数重载



---

#### 重写



---

#### 重定义



---



#### 静态存储区

```c++
#include<iostream>
using namespace std;

int main(){
       
    static int a;//全局静态变量 
    
    void print(int& a){
        static int b;//局部静态变量
        cout<<b<<endl;
    }
    
    static int sum(int& a, in& b){//静态函数
        return a+b;
    }
    
    animal::eat();
    
    }   
    return 0;
}

class animal{
public:
    animal(){};

    static weight;//类的静态成员，不再属于对象

    static void eat(){//类的静态函数，不再属于对象
        //不可以引用类中的非静态成员
        cout<<"eat"<<endl;
    }
```



#### 指针数组与数组指针

```c++
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;

int main(){

    //测试变量1--字符串常量、指针数组（数组）
    char aa[] = "hello";  //字符串常量
    char const *arr[] = {"aaa","bbb","cfs","ddd"}; //指针数组，是一个数组，每个元素是一个指针；想象成(char*) arr[];

    //测试输出1
    cout << "aa[2]: " << aa[2] << endl; // 'l'
    cout << "aa: " << aa << endl;  //hello
    cout << "*aa: " << *aa << endl;  //'h'
    
    cout << "arr[2]: " << arr[2] << endl; // ccc
    cout << "*arr[2]: " << *arr[2] << endl;  //'c'
    cout << "&arr[2]: " << &arr[2] << endl;  // &ccc
    cout << "*arr: " << *arr << endl;  // aaa
    cout << "&arr: " << &arr << endl;  // &aaa
    cout << "&arr[0]: " << &arr[0] << endl;  // &aaa
    cout << "arr: " << arr << endl;  //&aaa
	//
    
    cout << "------------------------------------" << endl;
    cout << "------------------------------------" << endl;

    //测试变量2--数组指针（指针）

    int(*arrPtr)[10] = NULL;   // 数组指针，一个指针，它指向一个有10个int元素的数组
    int matrix[3][10] = { 0 };  
    arrPtr = matrix;

    (*arrPtr)[0] = 5;
    matrix[2][9] = 6;
    arrPtr++;
    (*arrPtr)[1] = 7;

    //测试输出2
    for(int i = 0;i < 3;i++){
        for(int j = 0;j < 10;j++)
            cout << matrix[i][j] << " ";
        cout << endl;
    }
    /*
    5 0 0 0 0 0 0 0 0 0
    0 7 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 6
    */

    cout << "------------------------------------" << endl;
    cout << "------------------------------------" << endl;
	
    //测试变量3--字符指针
    char const *ptr = "C language"; 
    cout<<"ptr: " <<ptr<<endl;        //ptr: C language
    cout<<"ptr[3]: " <<ptr[3]<<endl;  //ptr[3]: a
    ptr += 2;
    cout<<"ptr+2: " << ptr <<endl;    //ptr+2: language
	//字符指针与字符数组的区别：
    //1、占用空间不同。数组所占空间取决于数组的长度，而指针只占用4字节，用以存放字符串的首地址。
    //2、赋值方式不同指针本身是变量，所以可以这样char *ps; ps = "C language!"; 赋值，
    //而数组不能这样char A[20];A = "C language!;赋值，而要逐个赋值。
    
    return 0;
}
```



#### C++程序内存管理



**BSS段（未初始化数据区）：**

**数据段（已初始化数据区）：**

**代码段：**







## 五、C++11新特性

#### 右值引用



#### 引用折叠



#### lambda表达式



#### enum

