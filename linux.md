## Linux

#### 常用的linux指令

- 求助 --help  man  info  doc

- 关机  who  sync  shutdown

- Vim模式：

  - 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；

    编辑模式（Insert mode）：按下 "i" 等按键之后进入，可以对文本进行编辑；

    指令列模式（Bottom-line mode）：按下`:`按键之后进入，用于保存退出等操作。

    | 命令 | 作用                                                         |
    | ---- | ------------------------------------------------------------ |
    | :w   | 写入磁盘                                                     |
    | :w!  | 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 |
    | :q   | 离开                                                         |
    | :q!  | 强制离开不保存                                               |
    | :wq  | 写入磁盘后离开                                               |
    | :wq! | 强制写入磁盘后离开                                           |

- 文件管理

  - ### 1. ls

    列出文件或者目录的信息，目录的信息就是其中包含的文件。

    ```
    # ls [-aAdfFhilnrRSt] file|dir
    -a ：列出全部的文件
    -d ：仅列出目录本身
    -l ：以长数据串行列出，包含文件的属性与权限等等数据
    ```

    ### 2. cd

    更换当前目录。

    ```
    cd [相对路径或绝对路径]
    ```

    ### 3. mkdir

    创建目录。

    ```
    # mkdir [-mp] 目录名称
    -m ：配置目录权限
    -p ：递归创建目录
    ```

    ### 4. rmdir

    删除目录，目录必须为空。

    ```
    rmdir [-p] 目录名称
    -p ：递归删除目录
    ```

    ### 5. touch

    更新文件时间或者建立新文件。

    ```
    # touch [-acdmt] filename
    -a ： 更新 atime
    -c ： 更新 ctime，若该文件不存在则不建立新文件
    -m ： 更新 mtime
    -d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date="日期或时间"
    -t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
    ```

    ### 6. cp

    复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。

    ```
    cp [-adfilprsu] source destination
    -a ：相当于 -dr --preserve=all
    -d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
    -i ：若目标文件已经存在时，在覆盖前会先询问
    -p ：连同文件的属性一起复制过去
    -r ：递归复制
    -u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
    --preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了
    ```

    ### 7. rm

    删除文件。

    ```
    # rm [-fir] 文件或目录
    -r ：递归删除
    ```

    ### 8. mv

    移动文件。

    ```
    # mv [-fiu] source destination
    # mv [options] source1 source2 source3 .... directory
    -f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
    ```

- 权限管理

  - ```
    # chmod [ugoa]  [+-=] [rwx] dirname/filename
    - u：拥有者
    - g：所属群组
    - o：其他人
    - a：所有人
    - +：添加权限
    - -：移除权限
    - =：设定权限
    ```

  - 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。

  - 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。

  - ```
    # ln [-sf] source_filename dist_filename
    -s ：默认是实体链接，加 -s 为符号链接
    -f ：如果目标文件存在时，先删除目标文件
    ```

  - 实体链接：

    在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。

    删除任意一个条目，文件还是存在，只要引用数量不为 0。

    有以下限制：不能跨越文件系统、不能对目录进行链接。

  - 符号链接：

    符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。

    当源文件被删除了，链接文件就打不开了。

    因为记录的是路径，所以可以为目录建立符号链接。

- 获取文件内容

  - ### 1. cat

    取得文件内容。

    ```
    # cat [-AbEnTv] filename
    -n ：打印出行号，连同空白行也会有行号，-b 不会
    ```

    ### 2. tac

    是 cat 的反向操作，从最后一行开始打印。

    ### 3. more

    和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。

    ### 4. less

    和 more 类似，但是多了一个向前翻页的功能。

    ### 5. head

    取得文件前几行。

    ```
    # head [-n number] filename
    -n ：后面接数字，代表显示几行的意思
    ```

    ### 6. tail

    是 head 的反向操作，只是取得是后几行。

    ### 7. od

    以字符或者十六进制的形式显示二进制文件。

- 指令与文件搜索

  - ### 1. which

    指令搜索。

    ```
    # which [-a] command
    -a ：将所有指令列出，而不是只列第一个
    ```

    ### 2. whereis

    文件搜索。速度比较快，因为它只搜索几个特定的目录。

    ```
    # whereis [-bmsu] dirname/filename
    ```

    ### 3. locate

    文件搜索。可以用关键字或者正则表达式进行搜索。

    locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。

    ```
    # locate [-ir] keyword
    -r：正则表达式
    ```

    ### 4. find

    文件搜索。可以使用文件的属性和权限进行搜索。

    ```
    # find [basedir] [option]
    example: find . -name "shadow*"
    ```

- 进程管理：

  - ### 1. ps

    查看某个时间点的进程信息。

    示例：查看自己的进程

    ```
    # ps -l
    ```

    示例：查看系统所有进程

    ```
    # ps aux
    ```

    示例：查看特定的进程

    ```
    # ps aux | grep threadx
    ```

    ### 2. pstree

    查看进程树。

    示例：查看所有进程树

    ```
    # pstree -A
    ```

    ### 3. top

    实时显示进程信息。

    示例：两秒钟刷新一次

    ```
    # top -d 2
    ```

    ### 4. netstat

    查看占用端口的进程

    示例：查看特定端口的进程

    ```
    # netstat -anp | grep port
    ```

- 系统管理：

  - top：动态显示进程信息和系统运行统计信息

    free：显示系统运行的统计信息：内存 缓存 缓冲 交换分区；

    ipcs -s/-q/-m：分别显示系统的信号量 消息队列 共享内存

    ipcrm -s/-q/-m id ：根据id 删除信号量 消息队列 共享内存

    lsof：（list open file）：显示系统当前打开的所有文件描述符，所有所有。。。所有

    mpstat：实时监控多处理器系统上每个处理器的使用情况

    vmstat：实时输出系统各个资源的使用情况

- 网络通讯命令:

  - ping：测试网络连通性；

    ifconfig/ip：显示或设置网络设备；

    netstat/ss：显示网络相关信息；

    service：管理系统运行的服务器；

    mail：查看、发送电子邮件；

    write：给用户发信息；

    tcpdump：抓包工具

    nc：快速构建网络连接；

    strace：跟踪程序运行过程中执行的系统调用和接受到的信号，并将系统调用名，参数，返回值以及信号名输出到 标准输出 或者 指定的文件中

    netstat：打印本地网卡接口上的全部连接、路由表信息、网卡接口信息。常用：显示tcp连接以及状态。

- 打包压缩

  - ### 1. gzip

    gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。

    经过 gzip 压缩过，源文件就不存在了。

    有 9 个不同的压缩等级可以使用。

    可以使用 zcat、zmore、zless 来读取压缩文件的内容。

    ```
    $ gzip [-cdtv#] filename
    -c ：将压缩的数据输出到屏幕上
    -d ：解压缩
    -t ：检验压缩文件是否出错
    -v ：显示压缩比等信息
    -# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
    ```

    ### 2. bzip2

    提供比 gzip 更高的压缩比。

    查看命令：bzcat、bzmore、bzless、bzgrep。

    ```
    $ bzip2 [-cdkzv#] filename
    -k ：保留源文件
    ```

    压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。

    ```
    $ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
    $ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
    $ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
    -z ：使用 zip；
    -j ：使用 bzip2；
    -J ：使用 xz；
    -c ：新建打包文件；
    -t ：查看打包文件里面有哪些文件；
    -x ：解打包或解压缩的功能；
    -v ：在压缩/解压缩的过程中，显示正在处理的文件名；
    -f : filename：要处理的文件；
    -C 目录 ： 在特定目录解压缩。
    ```

#### linux内核中的Timer 定时器机制

- 低精度时钟：Linux 2.6.16之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。（tick是系统的相对时间单位，也称为系统的时基，来源于定时器的周期性中断）
  - 系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。
  - 内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。
  - 设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。
- 高精度时钟：之前，linux只能支持m级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计，内核采用新的定时器hrtimer。
  - 通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。
  - 在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。**hrtimer是基于事件的，不会周期性出发tick中断**，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。
  - 引入了**dynamic tick**，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。
- 新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：
  - 时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。
  - 时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。
  - 当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。
- 低精度和高精度时钟的区别：
  - hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；
  - 高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。
  - 旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。
  - 新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。