### 一些需要注意的点

- **数据类型占用空间：**

  |  数据类型   |                  占用空间大小                   |
  | :---------: | :---------------------------------------------: |
  |   `short`   |                      2字节                      |
  |    `int`    |                      4字节                      |
  |   `long`    | Windows-4字节，Linux32位-4字节，Linux64位-8字节 |
  | `long long` |                      8字节                      |
  |   `float`   |                      4字节                      |
  |  `double`   |                      8字节                      |
  |   `char`    |                      1字节                      |
  |   `bool`    |                      1字节                      |
  |   `指针`    |    32位-4字节，64位-8字节（与数据类型无关）     |
  |   `引用`    |             4字节（本质是指针常量）             |
  |             |                                                 |

- 生成随机数

  添加随机数种子，作用是利用当前系统时间生成随机数，防止每次随机数都一样

  ```c++
  #include<ctime>
  srand((unsigned int)time(NULL))
  ```

- 一维数组定义方式

  ```c++
  int arr[5];
  int arr[5] = {1,2,3,4,5};
  int arr[ ] = {1,2,3,4,5};
  ```

- 函数的分文件编写

  ```c++
  /*
  创建swap.h 头文件，写入include 与 函数声明；
  创建swap.cpp 源文件，写入include"swap.h" 与 函数实现；
  在其他.cpp文件中，只要头文件加入 #include"swap.h" ，就可以使用swap()函数；
  */
  ```

- 空指针与野指针

  空指针：指针变量指向内存中编号为0的空间，主要用来初始化指针变量；但是空指针指向的内存是不可以访问的；

  野指针：

- `const`修饰指针

  - `const`修饰指针：指针的指向可以修改，即指针本身可以修改，但是指针指向的内存空间中的内容是不允许修改的；

    ```c++
    const int* p = &a; //----常量指针
    //可以修改p的指向，但是不能修改a的值
    ```

  - `const`修饰常量：指针的指向不能修改，也就是指针本身不可改，但是指针指向的内存空间中的内容是可以修改的；

    ```c++
    int* const p = &a; //----指针常量
    //p的指向是定死在a的，不能够修改的，但是a的值是可以修改的；
    ```

  - `const`即修饰指针，又修饰常量：指针的指向不能够修改，同时指针指向的内存空间中的内容也是不能够修改的；

    ```c++
    const int* const p = &a;
    //p的指向不能修改，a的值也不能修改；
    ```

- 结构体定义与使用

  - 通过结构体创建变量的三种方式：
    - `struct `结构体名 变量名
    - `struct `结构体名 变量名 = {成员1，成员2……}
    - `struct` 结构体名{   }；变量名    //定义结构体时顺便创建变量；

- C++程序内存分区

  - 代码区：放函数体的二进制代码，由操作系统进行管理；
  - 全局区：存放全局变量、静态变量、常量；
  - 栈区：由编译器自动分配与释放，存放函数的参数值、局部变量；//不要返回局部变量的地址，因为函数运行完后，栈区开辟的数据自动释放；
  - 堆区：由程序员分配与释放，若没有释放，在程序结束时由操作系统回收；

  在程序运行前，程序编译后，分为两个区域：代码区、全局区；

  在程序运行后，又增加栈区、堆区；

- `new`操作符

  - `new 数据类型`  由`delete`来释放；

    ```c++
    int* p = new int(10);
    delete p;
    int * arr = new int[10];
    delete [] arr;
    ```

- 引用

  -  引用占用的空间大小是4字节；

  - 引用必须初始化；并且在初始化后，不可以改变；

  - 引用可以作为函数的返回值；（可以用函数调用作为左值）（不要返回局部变量引用）

  - 引用的本质 是一个指针常量；（指向不能改变，但是指针所指的内容可以改变）

  - 常量引用主要用来修饰形参，防止误操作，防止形参改变实参；

  - 引用必须引一块合法的内存空间

    ```c++
    int& ref = 10; //引用本身需要一个合法的内存空间，因此是错误的
    const int& ref = 10;  //加入const就可以了，因为编译器优化代码，int temp = 10; const int& ret = temp;
    ```

- 函数的形参可以用数据类型来占位，还可以有默认参数

  ```c++
  void func(int a,int = 10)
  ```

- 函数重载

  - 重载满足条件：
    - 同一个作用域下；
    - 函数名称相同
    - 函数参数 `类型不同` 或者 `个数不同` 或者 `顺序不同`
    - 注意：函数的返回值不可以作用函数重载的条件；

- C++面向对象的三大特性为：封装、继承、多态

- 封装

  - 封装 的意义：1\ 将属性和行为作为一个整体，表现生活中的事物。2\ 将属性和行为加以权限控制。

  - 权限

    - public：类内、类外均可访问；
    - protected：类内可访问，类外不可访问，子类可以访问父类protected内容；
    - private：类内可以访问，类外不可访问，子列不可访问父类private内容，友元可以访问private内容；

  - `struct`与`class`的区别：`struct`默认的权限为公共，`class`默认的权限为私有；

  - 将类的定义与声明放入头文件中

    - 在头文件中建立.h文件，在源文件中建立.cpp文件

    - .h文件中

      ```c++
      #pragma once
      #include<iostream>
      using namespace std;
      
      //定义类，并声明成员函数与成员变量
      ```

    - .cpp文件中

      ```c++
      #include"xx.h"
      
      //实现成员函数
      //注意此处为全局空间，相当于是类外实现，所以要加一个作用域，表明函数是成员函数
      ```

- 构造函数可以发生重载，析构函数不能够重载；

- 构造函数的三种调用方法

  ```c++
  //括号法
  person p3(p2);
  //显示法
  person p3 = person(p2);
  //隐式转换法
  person p3 = p2;
  ```

- 拷贝构造调用时机

  - 使用一个已经创建完毕的对象来初始化一个新对象
  - 值传递的方式给函数参数传值；
  - 以值方式返回`局部`对象；

- 深拷贝与浅拷贝问题

  - 浅拷贝：简单的赋值拷贝操作；

  - 深拷贝：在堆区重新申请空间，进行拷贝操作；

  - 如果利用编译器提供的拷贝构造函数，会做浅拷贝操作，也就是只有值的拷贝，没有地址的变动，析构函数中释放堆区内存时，利用delete函数完成释放，带来的问题就是堆区内存的重复释放。所以要利用深拷贝来解决这种问题，深拷贝在拷贝构造函数中，重新在堆区开辟内存，利用new函数，然后再完成拷贝操作；

    ```c++
    eg.m_height = new int(*p.m_height);
    ```

  - 如果有属性开辟在堆区的，一定要自己提供拷贝构造函数，以免浅拷贝带来问题；

- 初始化列表

  ```c++
  构造函数(): 属性1(值1),属性2(值2)，……{}
  Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}     //没有；号
  ```

- 类对象作为类成员：先构造对象成员，再构造类本身`（由内往外）`；析构相反，先析构类本身，再析构成员`（由外向内）`。

- 静态成员：**`static`**

  - 静态成员变量
    - 所有对象共享同一份数据 
    - 在编译阶段分配内存
    - 类内声明，类外初始化；
    - 访问方式:
      - 通过对象进行访问； P.m_a
      - 通过类名进行访问   Person::m_a
    - 一定要初始化，否则要报错；
  - 静态成员函数
    - 所有对象共享同一个函数；
    - 静态成员函数只能访问静态成员变量；
  - 静态成员变量/函数 也是有访问权限的；

- 类的成员变量和成员函数是分开存储的，非静态成员变量占对象空间，静态成员变量不占对象空间，函数也不占对象空间，所有函数共享`一个函数实例`，静态成员函数也不占对象空间；  `空对象占用内存空间为1，为的是区分空对象占内存的位置`

- 针对所有函数共享一个函数实例的问题，多个对象通过this指针来实现区分，**`this指针指向被调用的成员函数所属的对象`**，

  ```c++
  //所以在非静态成员函数中返回对象本身，可以用 return *this
  Person& Personadd(){
  	return * this;
  }
  //这里的返回值是引用，如果不加引用，返回的就是值，同时也是值传递，创建一个新的对象返回，后续对其操作就不再是在原内存地址上了；
  ```

- 空指针可以调用成员函数，但不可以调用成员变量（包括用到成员变量的成员函数），因为访问成员变量会用到this指针，所以需要加一个判断（判断this是否为空）以保证代码的健壮性；

- **`const`**修饰成员函数

  - 常函数：

    - 成员函数**`后`**加const后，称这个函数为**常函数**；
    - 常函数内不可以修改成员属性；
    - 成员属性声明时加关键字`mutable`后，在常函数中依然可以修改；

    ```c++
    class Person{
    public:
    	int age;
    	mutable string name;
    public:
    	void printInfo() const{ //常函数
    		cout<<"name:"<<name<<" age:"<<age<<endl;
    	}
    }
    ```

  - 常对象：

    - 声明对象前加`const`称该对象为常对象；
    - 常对象只能调用常函数；不能修改成员变量的值，mutable修饰的可以修改；

  - this指针的本质时指针常量，指向不可以修改，在前面加const后，修饰的是this指针，让指针指向的值也不再可以修改；

- 友元：友元的目的就是让一个函数或者类 访问另一个类中私有成员；

  - 关键字为`friend`；
  - 友元的三种实现：
    - 全局函数做友元；`在类中声明全局函数，并在前面加friend`
    - 类做友元；`类中声明好朋友类，friend class xxx；`
    - 成员函数做友元；`类中声明好朋友类内成员函数； friend Goodgay::visit();`
  - 类外可以实现构造函数和成员函数，均需要类内声明，类外加作用域；

- 运算符重载

  - 运算符重载的时候允许出现函数重载；

  - 通常不会利用成员函数重载<<运算符，因为无法实现cout在左侧，只能利用全局函数重载<<

    ```c++
    ostream& operator<<(ostream& out,Person& P){
    	out<<ddddddd<<endl;
    	return out;
    }//实现链式重载，才能保证链式编程；
    ```

  - 递增运算符重载++

    - 前置++返回引用，后置++返回值；`返回引用是为了一直对一个数据进行递增操作`

  - 赋值运算符重载=

    - 先判断是否有属性在堆区，如果有先释放干净，再进行深拷贝，返回值为自身；`return *this;`

- c++编译器至少给一个类添加4个函数

  1. 默认构造函数(无参，函数体为空)
  2. 默认析构函数(无参，函数体为空)
  3. 默认拷贝构造函数，对属性进行值拷贝
  4. 赋值运算符 operator=, 对属性进行值拷贝

  **注意：**其中赋值运算符一开始是不会产生的，只有在用到的时候才会产生，并且存在编译器拒绝产生赋值运算符的情况。详情见[C++-3]().

- 继承中的对象模型

  - 在父类中所有非静态成员属性都会被子类继承下去
  - 父类中私有成员属性是被编译器给隐藏了，因此是访问不到的，但是确实是被继承下去了；

- 继承中构造和析构的顺序

  - 子类创建对象时，也会调用父类的构造函数；
  - 构造先构造父类，再构造子类，析构是先析构子类，再析构父类；

- 多继承容易出现菱形继承问题，如果两个父类有相同的数据，就需要加以作用域来区分；

  - 解决方法就是利用**虚继承**，在继承之间加上关键字virtual变为虚继承

    ```c++
    class sheep : virtual public Animal{
    
    };
    //虚继承
    
    ```

- **多态**

  - 多态分为静态多态与动态多态
    - 静态多态：函数重载、运算符重载等属于静态多态，采用复用函数名的方式；
    - 动态多态：派生类和虚函数实现运行时的多态；
    - 区别：
      - 静态多态的函数地址是早绑定-编译阶段就确定函数的地址；
      - 动态多态的函数地址是晚绑定-运行阶段才确定函数地址；（利用虚函数实现晚绑定）
    - 动态多态满足条件：
      - 有继承关系；
      - 子类要重写父类的虚函数（重写：函数返回值类型、函数名、参数列表完全相同，virtual关键字可写可不写）（子类重写父类虚函数时，子类中的虚函数表内部会替换成子类的虚函数地址）
    - 动态多态的使用方式：父类的指针或者引用 指向 子类对象；

- 纯虚函数与抽象类

  - 在多态中，通常父类中虚函数的实现是毫无意义的，主要是调用子类重写的内容，因此可以将虚函数改为纯虚函数；
  - 当类中有了纯虚函数，这个类也称为抽象类；
  - 抽象类：
    - 无法实例化对象；
    - 子类必须重写抽象类中的纯虚函数，否则也属于抽象类；
  - 纯虚函数：
    - 只要有一个纯虚函数，这个类就称为抽象类；
    - 抽象类中的纯虚函数相当于告诉编译器，创建一个和纯虚函数名相同的一个函数表，里面包含子类的函数名相同的入口地址；
    - 多态的目的就是让函数的接口更通用化，通过一个父类指针，根据对象不同，调用多种形态的函数；

- 虚析构与纯虚析构

  - 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，因此要将父类中的析构函数改为虚析构或者纯虚析构；
  - 共性：
    - 可以解决父类指针释放子类对象时不干净的问题；（如果子类没有用到堆区，那么就不需要虚析构或纯虚析构）
    - 都需要有具体的函数实现；
  - 区别：
    - 如果是纯虚析构，那么该类属于抽象类，无法实例化对象；